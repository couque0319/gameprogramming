
# 게임 프로그래밍 C언어 강의 노트

## 1. 카드 표시 및 게임

### 1.1 트럼프 카드 구조체 설계

트럼프 카드는 다음과 같이 구성됩니다:
- **4개의 모양**: ♠(스페이드), ◆(다이아몬드), ♥(하트), ♣(클로버)
- **각 모양당 13장**: 총 52장의 카드
- **구조체로 표현**: 숫자(또는 문자)와 모양의 두 가지 데이터

#### 카드 우선순위
- 스페이드(♠): 1순위 (order=0)
- 다이아몬드(◆): 2순위 (order=1)  
- 하트(♥): 3순위 (order=2)
- 클로버(♣): 4순위 (order=3)

#### 카드 구조체 멤버
- `order`: 카드의 우선순위
- `shape`: 카드 모양 (2byte 크기의 완성형 기호)
- `number`: 카드의 숫자 또는 문자

### 1.2 카드 생성 알고리즘

1. **모양 저장**: 2차원 배열에 카드 모양(♠◆♥♣) 저장
2. **반복문**: 카드 순위를 `order` 멤버에 저장
3. **Switch-case문**: 특수 카드 처리
   - 1 → 'A' (Ace)
   - 11 → 'J' (Jack)
   - 12 → 'Q' (Queen)  
   - 13 → 'K' (King)

### 1.3 카드 출력

- **문자형 카드**: `%-2c` (2자리 왼쪽 맞춤)
- **숫자형 카드**: `%-2d` (2자리 왼쪽 맞춤)

### 1.4 카드 섞기 알고리즘

#### 방법 1 (기본)
```
1단계: 난수 rnd 발생 → a[0]과 a[rnd] 교환
2단계: 난수 rnd 발생 → a[1]과 a[rnd] 교환
... 반복
```

#### 방법 2 (개선)
- 문제점: 난수 rnd가 현재 위치 i와 같으면 교환이 일어나지 않음
- 해결책: rnd == i인 경우 다시 난수 발생

---

## 2. 음계와 피아노 건반

### 2.1 음계의 기본 개념

- **음계(Musical Scale)**: 음을 높이 순서로 배열한 것
- **음정(Tone)**: 음 높이의 차이
- **절대음정**: 피아노 중앙의 라(A) = 440Hz 기준
- **옥타브(Octave)**: 1:2의 음정비

### 2.2 12평균율

- **12평균율**: 한 옥타브를 12개의 반음정으로 균등 분할
- **주파수 비율**: 약 1.0594:1 (모든 음계에 동일 적용)
- **계산 공식**: 라(440Hz)를 기준으로 각 음계 주파수 계산

### 2.3 주요 음계별 주파수 (옥타브 4 기준)

| 음계 | 주파수(Hz) |
|------|------------|
| 도(C) | 262 |
| 레(D) | 294 |
| 미(E) | 330 |
| 파(F) | 349 |
| 솔(G) | 392 |
| 라(A) | 440 |
| 시(B) | 494 |

### 2.4 음 출력 함수

#### Windows API 사용
```c
#include <windows.h>
Beep(frequency, duration);  // frequency: 주파수, duration: 지속시간(ms)
```

#### 음계 인덱스 배열
```c
int index[] = {0, 2, 4, 5, 7, 9, 11, 12};  // 도#, 레#, 파#, 솔#, 라# 제외
```

### 2.5 키보드 입력과 음 출력

- **getch() 사용**: Enter키 없이 즉시 입력 처리
- **문자-숫자 변환**: 문자 '1' → 숫자 0 (ASCII 값에서 49를 빼기)

---

## 3. 자료 구조

### 3.1 자료 구조 개념

**자료 구조(Data Structure)**: 컴퓨터상에서 데이터와 데이터 간의 상호 관계를 정의하는 것

#### 분류
- **선형 구조**: 연결 리스트, 스택, 큐, 데크
- **비선형 구조**: 트리, 그래프

### 3.2 연결 리스트 (Linked List)

#### 특징
- **노드(Node)**: 데이터 필드 + 링크 필드
- **동적 메모리**: 필요한 만큼만 메모리 사용
- **삽입/삭제**: 임의 위치에서 용이

#### 게임에서의 활용
- **Replay 기능**: 버튼 조작 데이터를 순서대로 저장
- **장점**: 메모리 효율성, 순차 재생 가능

#### 구현
- **자기 참조 구조체**: 구조체 내부에 같은 타입의 포인터 멤버
- **동적 할당**: malloc, free 함수 사용

### 3.3 스택 (Stack)

#### 특징
- **LIFO**: Last In, First Out (후입선출)
- **top**: 데이터 추가/삭제가 이루어지는 위치
- **한쪽 끝에서만**: 모든 연산이 top에서만 수행

#### 실생활 예시
- **찜질방 수건 더미**: 위에서 추가, 위에서 가져가기
- **원카드 게임**: 버리는 카드 더미, 가져가는 카드 더미

#### 주요 연산
- **Push**: 데이터 추가 (top에)
- **Pop**: 데이터 삭제 (top에서)

### 3.4 동적 메모리 관리

#### 문제점
- **배열의 한계**: 크기를 미리 정해야 함
- **메모리 낭비**: 사용하지 않는 공간

#### 해결책
- **동적 할당**: 필요할 때마다 메모리 확보
- **동적 해제**: 불필요해지면 메모리 반환
- **함수**: malloc() - 할당, free() - 해제

---

## 4. 데이터 정렬

### 4.1 문자열 정렬의 문제점

#### ASCII 코드 차이
- **대문자 'A'**: ASCII 65
- **소문자 'a'**: ASCII 97
- **문제**: 대소문자 혼용 시 정렬 결과 오류

### 4.2 해결 방법

#### 대소문자 통일
- **함수 사용**: `upper_to_lower()` 함수로 대문자 → 소문자 변환
- **임시 변환**: 비교 시에만 소문자로 변환, 원본은 유지
- **정렬**: 소문자 기준으로 알파벳 순서 정렬

### 4.3 정렬 과정

1. **파일 읽기**: 텍스트 파일에서 컴퓨터 용어 읽기
2. **전처리**: 대문자를 소문자로 임시 변환
3. **비교 정렬**: 소문자 기준으로 알파벳 순서 정렬
4. **결과 저장**: 원본 형태로 배열에 저장
